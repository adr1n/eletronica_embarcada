#include "mcc_generated_files/mcc.h"
#define BUFFER_MAX 3    ///< Máxima quantidade de bytes a serem recebidos.
#define MOTOR_TEMP 0
#define LUM_SENSOR 1

union{                  ///< União entre os nibles a serem transmitidos.
    uint16_t temp;         ///< Valor de 16 bits que contem os nibles n3, n2, n1 e n0.
    struct{
        uint8_t lsb : 8; ///< Byte n0 
        uint8_t msb : 8; ///< Byte n1  
    };
}TempTx; ///< Variável com os valores Tx.

union{                  ///< União entre os nibles a serem transmitidos.
    uint16_t lum;         ///< Valor de 16 bits que contem os nibles n3, n2, n1 e n0.
    struct{
        uint8_t lsb : 8; ///< Byte n0 
        uint8_t msb : 8; ///< Byte n1  
    };
}LumTx; ///< Variável com os valores Tx.

union{  
    uint16_t gainLum; ///< Valor de 16 bits que contem os nibles n3, n2, n1 e n0.
    struct{
        uint8_t lsb;
        uint8_t msb; ///< Byte n1  
    };
}gainLumRx;

union{    
    uint16_t gainTemp;///< Valor de 16 bits que contem os nibles n3, n2, n1 e n0.
    struct{
        uint8_t lsb;
        uint8_t msb;
    };
}gainTempRx;

union{
    uint16_t duty;
    struct{
        uint8_t msb; ///< Byte n0 
        uint8_t lsb; ///< Byte n1  
    };
}dutyRx;

uint8_t bufferRx[BUFFER_MAX];///< Buffer de Rx
uint8_t countRx = 0;    ///< Contador de bytes recebidos (ponteiro)
bool TxActivate = true;

/*
                         Main application
 */
void analisaRx(){
    switch(bufferRx[0]){
        case 0x80:
            if (bufferRx[2]) {
                TxActivate = true;
            }
            else {
                TxActivate = false;
            }
        case 0x81: //PWM Duty
            dutyRx.msb = bufferRx[1]; ///< Byte n0 
            dutyRx.lsb = bufferRx[2];
            EPWM1_LoadDutyValue(dutyRx.duty);
        case 0x82: //Ganho de Temperatura
            gainTempRx.msb = bufferRx[1];
            gainTempRx.lsb = bufferRx[2];
        case 0x83: //Ganho de Luminosidade
            gainLumRx.msb = bufferRx[1];
            gainLumRx.lsb = bufferRx[2];
        default:
            break;                    
    }
}

void enviaTx(){
    if(TMR1_HasOverflowOccured() && TxActivate){
        EUSART_Write(0x80);               
        EUSART_Write(TempTx.msb);            
        EUSART_Write(TempTx.lsb); 
        EUSART_Write(LumTx.msb);
        EUSART_Write(LumTx.lsb); 
    }
}

void main(void)
{
    // initialize the device
    SYSTEM_Initialize();

    // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
    // Use the following macros to:

    // Enable the Global Interrupts
    //INTERRUPT_GlobalInterruptEnable();

    // Enable the Peripheral Interrupts
    //INTERRUPT_PeripheralInterruptEnable();

    // Disable the Global Interrupts
    //INTERRUPT_GlobalInterruptDisable();
    
    // Disable the Peripheral Interrupts
    //INTERRUPT_PeripheralInterruptDisable();
    
    gainTempRx.gainTemp = 2;
    gainLumRx.gainLum = 2;
    while (1)
    {
        LumTx.lum = ADC_GetConversion(MOTOR_TEMP);
        LumTx.lum = LumTx.lum*gainLumRx.gainLum;
        TempTx.temp = ADC_GetConversion(LUM_SENSOR);
        TempTx.temp = TempTx.temp*gainTempRx.gainTemp;
        
        if(EUSART_is_rx_ready()){               // Se chega um byte 
            uint8_t rxChar = EUSART_Read();
            if(rxChar&10000000){                 // Se for o inicio do quadro
                countRx = 0;                    // zera contador
            }
            else if(countRx<BUFFER_MAX){         // e o buffer não etsá cheio
                bufferRx[countRx] = rxChar; // guarda valor
                countRx++;
            }
           
            else if(countRx == BUFFER_MAX){      // Se for o final
                analisaRx(); // analiza dados recebidos
                enviaTx();   // envia dados
            }
        }       
    }   
}
